<?php
/**
 * Created by PhpStorm.
 * User: seedteam
 * Date: 03.03.20
 * Time: 18:24
 */


require_once('include/SugarFields/Fields/Base/SugarFieldBase.php');

class SugarFieldMeansCommunication extends SugarFieldBase
{

    public function setup($parentFieldArray, $vardef, $displayParams, $tabindex, $twopass = true)
    {
        $option=Means_of_Communication::get_type_comm();
        if (!isset($vardef['options_list']) && !empty($option)) {
            $vardef['options_list'] = $option;
        }
        parent::setup($parentFieldArray, $vardef, $displayParams, $tabindex, $twopass); // TODO: Change the autogenerated stub
    }

    public function save(&$bean, $params, $field, $properties, $prefix = '')
    {
        if (empty($params['record'])) {
            // если не пустые данные и запись создается(record пустой) сохраняем все элементы
            if(!empty($params[$field])) {
                foreach ($params[$field] as $k => $v) {
                    $seedMeansCommunication = new Means_of_Communication();
                    $seedMeansCommunication->sort = $v['sort'];
                    $seedMeansCommunication->value_type = $v['value_type'];
                    $seedMeansCommunication->value = $v['value'];
                    $seedMeansCommunication->name = $params['module'] . ' ' . $bean->id;
                    $seedMeansCommunication->parent_type = $params['module'];
                    $seedMeansCommunication->parent_id = $bean->id;
                    $seedMeansCommunication->save();
                }
            }
        } else {
            global $db;
            $diff_rm=[];
            $diff_add_value=[];
            // получаем старые данные
            $old_values = Means_of_Communication::get_id_arr($params['module'],$bean->id);
            //print_array($params[$field]);
            $new_values=[];
            // если поле пришло не пустым
            if(!empty($params[$field])){
            foreach ($params[$field] as $k => $v){
                // если поле id не пустое то добавляем к массиву для проверки на удаление
                if(!empty($v['id'])){
                    $new_values[]=$v['id'];
                }
            }
                if(empty($new_values) and !empty($old_values)){
                /*
                 * если поле для сравнения пустое а массив старых значений не ппуст,
                 * то добавляем весь массив старых значений на удаление
                 */
                    $diff_rm=$old_values;
                } elseif (empty($new_values) and empty($old_values)) {
                    /*
                     * если массив для сравнения пуст и массив старых значений пуст
                     */
                    $diff_rm=null;
                    $diff_add=null;
                } else {
                    /*
                     * если поле для не пустое и массив старых значений не ппуст,
                     * то сравниваем 2 массива
                     */
                    $diff_rm = array_diff($old_values, $new_values);
                }
                // удаляем удаленные элементы
                if(!empty($diff_rm)){
                    foreach ($diff_rm as $v){
                        $seedMeansCommunication=BeanFactory::getBean('Means_of_Communication',$v);
                        $seedMeansCommunication->mark_deleted($v);
                        $seedMeansCommunication->save();
                    }
                }
                // если пришло не пустое поле
                if(!empty($params[$field])) {
                    foreach ($params[$field] as $k => $v) {
                        $seedMeansCommunication = new Means_of_Communication();
                        if(!empty($v['id'])){
                            $seedMeansCommunication->retrieve($v['id']);
                        }
                        $seedMeansCommunication->sort = $v['sort'];
                        $seedMeansCommunication->value_type = $v['value_type'];
                        $seedMeansCommunication->value = $v['value'];
                        $seedMeansCommunication->name = $params['module'] . ' ' . $bean->id;
                        $seedMeansCommunication->parent_type = $params['module'];
                        $seedMeansCommunication->parent_id = $bean->id;
                        $seedMeansCommunication->save();
                    }
                }
            } else {
                // если поле пришло пустым проверяем были ли до этого записи
                $diff_rm = Means_of_Communication::get_id_arr($params['module'],$bean->id);
                if(!empty($diff_rm)){
                    // если не пустой массив старых связанных контактов, то удаляем их
                    foreach ($diff_rm as $v){
                        $seedMeansCommunication=BeanFactory::getBean('Means_of_Communication',$v);
                        $seedMeansCommunication->mark_deleted($v);
                        $seedMeansCommunication->save();
                    }
                }
            }

        }

//        print_array('********$bean*********', 0, 1);
//        print_array($bean->id, 0, 1);
//        print_array('*********$field********', 0, 1);
//        print_array($field, 0, 1);
//        print_array('*******$properties**********', 0, 1);
//        print_array($properties, 0, 1);
//        print_array('*********$prefix********', 0, 1);
//        print_array($prefix, 0, 1);

    }
    static function list_logik($data_row, $module_dir){
        return Means_of_Communication::get_value($module_dir,$data_row['ID']);

    }
}